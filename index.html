<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FanArt Compositor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #e5e5e5;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #2d2d2d; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        /* Checkerboard pattern */
        .checkerboard {
            background-image: 
                linear-gradient(45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #2a2a2a 75%), 
                linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* Drag Overlay */
        #drag-overlay {
            display: none;
            background: rgba(59, 130, 246, 0.5);
            border: 4px dashed #60a5fa;
        }
        body.dragging #drag-overlay {
            display: flex;
        }

        /* Brush Cursor */
        #brush-cursor {
            position: fixed;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
            border-radius: 50%;
            z-index: 50;
            display: none;
            transform: translate(-50%, -50%);
        }

        /* Canvas States */
        #viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none; 
            z-index: 10;
        }
        
        #viewport.panning {
            cursor: grab !important;
        }
        #viewport.panning:active {
            cursor: grabbing !important;
        }
        
        #viewport.disabled {
            cursor: not-allowed !important;
        }
        
        #viewport.cropping {
            cursor: default !important;
        }

        /* Backdrop Dimmer (Dims the workspace outside image) */
        #backdrop-dimmer {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.9); /* Significantly increased dimming */
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .cropping #backdrop-dimmer {
            opacity: 1;
        }

        /* The transformed wrapper for the canvas */
        #canvas-wrapper {
            transform-origin: 0 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            z-index: 20;
        }

        /* Crop UI Overlay (Inside Wrapper to transform with image) */
        #crop-overlay-dom {
            position: absolute;
            inset: 0;
            pointer-events: none; 
            display: none;
            z-index: 30;
        }
        
        #crop-box {
            position: absolute;
            /* Massive box shadow to dim the image area outside crop */
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8); 
            border: 1px dashed white;
            pointer-events: auto; /* Catch clicks on the box for moving */
            cursor: move;
        }

        .crop-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border: 1px solid #333;
            pointer-events: auto;
            transform: translate(-50%, -50%); 
        }
        /* Handle Cursors */
        .handle-nw { top: 0; left: 0; cursor: nw-resize; }
        .handle-ne { top: 0; left: 100%; cursor: ne-resize; }
        .handle-sw { top: 100%; left: 0; cursor: sw-resize; }
        .handle-se { top: 100%; left: 100%; cursor: se-resize; }
        
        /* Error Console (Bottom Left) */
        #error-console {
            position: absolute;
            bottom: 20px; 
            left: 10px; 
            z-index: 100;
            display: flex;
            flex-direction: column-reverse;
            gap: 5px;
            pointer-events: none;
        }
        .console-msg {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            border-left: 3px solid #ef4444;
            animation: slideUp 0.2s ease-out;
            max-width: 300px;
            word-wrap: break-word;
        }
        .console-msg.info { border-left-color: #3b82f6; }

        /* Hint Legend */
        #hint-legend {
            position: absolute;
            top: 60px; 
            right: 10px;
            z-index: 90;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            color: #ccc;
            pointer-events: none;
            text-align: left; 
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.5s ease-in-out;
            opacity: 0; 
        }
        .key {
            color: #fff;
            font-weight: bold;
            background: rgba(255,255,255,0.1);
            padding: 1px 4px;
            border-radius: 3px;
        }

        /* Adjustment Drawer */
        #adj-drawer {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%) translateX(calc(100% - 24px)); 
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 60;
        }
        #adj-drawer:hover {
            transform: translateY(-50%) translateX(0);
        }
        
        /* Drawer Styling */
        .drawer-slider-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 8px;
        }
        .drawer-label {
            font-size: 10px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            justify-content: space-between;
        }
        .val-display {
            color: #60a5fa;
            font-family: monospace;
        }
        .drawer-divider {
            height: 1px;
            background-color: #374151;
            margin: 12px 0;
        }
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .section-title {
            font-size: 10px;
            color: #6b7280;
            font-weight: bold;
            text-transform: uppercase;
        }
        .section-reset {
            font-size: 9px;
            color: #3b82f6;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            opacity: 0.8;
        }
        .section-reset:hover { opacity: 1; color: white; }

        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px;
            border-radius: 50%; background: #3b82f6; margin-top: -6px; cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px;
        }

        .tool-btn { transition: all 0.2s; }
        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active { background-color: #3b82f6; color: white; border-color: #3b82f6; }
        .tool-btn:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(100%); }
        
        .icon-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            color: #9ca3af;
            background-color: #374151;
            transition: all 0.2s;
        }
        .icon-btn:hover { background-color: #4b5563; color: white; }
        .icon-btn:active { transform: scale(0.95); }
        .icon-btn:disabled { opacity: 0.4; cursor: not-allowed; color: #4b5563; background-color: #1f2937; }
        .icon-btn.active { background-color: #d97706; color: white; border: 1px solid #f59e0b; }

    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- Brush Cursor -->
    <div id="brush-cursor"></div>

    <!-- Drag Overlay -->
    <div id="drag-overlay" class="absolute inset-0 z-50 pointer-events-none items-center justify-center">
        <div class="text-white text-3xl font-bold bg-black/50 px-8 py-4 rounded-xl backdrop-blur-sm">
            Drop Images Here
        </div>
    </div>

    <!-- Error Console -->
    <div id="error-console"></div>

    <!-- Hint Legend -->
    <div id="hint-legend">
        <div><span class="key">Space</span> (Hold) to Pan</div>
        <div class="mt-1"><span class="key">Space</span> (Double-tap) to Reset View</div>
        <div class="mt-1"><span class="key">Wheel</span> to Zoom</div>
        <div class="mt-1"><span class="key">Ctrl+Wheel</span> or <span class="key">[ ]</span> Brush Size</div>
        <div class="mt-1"><span class="key">Ctrl+Click</span> Draw Line</div>
        <div class="mt-1"><span class="key">Ctrl+Z</span> Undo &bull; <span class="key">Ctrl+Y</span> Redo</div>
    </div>

    <!-- Adjustment Drawer (Right) -->
    <div id="adj-drawer" class="flex items-center">
        <!-- Lip -->
        <div class="w-6 h-24 bg-gray-800 rounded-l-lg border-y border-l border-gray-700 flex items-center justify-center cursor-pointer shadow-lg">
            <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
        </div>
        <!-- Drawer Content -->
        <div class="w-72 bg-gray-900 border border-gray-700 p-4 shadow-2xl rounded-bl-lg max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4 border-b border-gray-800 pb-2">
                <h3 class="text-xs font-bold text-gray-400 uppercase tracking-widest">Adjustments</h3>
                <button id="resetAdjBtn" class="text-[10px] text-blue-400 hover:text-white uppercase tracking-wider font-bold">Reset All</button>
            </div>
            <!-- Sliders -->
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Gamma</span> <span id="val-gamma" class="val-display">1.00</span></div>
                <input id="adj-gamma" type="range" min="0.0" max="2.0" step="0.01" value="1.0" class="w-full" data-default="1.0">
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Shadows</span> <span id="val-shadows" class="val-display">0</span></div>
                <input id="adj-shadows" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Highlights</span> <span id="val-highlights" class="val-display">0</span></div>
                <input id="adj-highlights" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
            <div class="drawer-divider"></div>
            <div class="section-header">
                <span class="section-title">Levels</span>
                <button id="resetLevelsBtn" class="section-reset">Reset</button>
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Black Point</span> <span id="val-l-black" class="val-display">0</span></div>
                <input id="adj-l-black" type="range" min="0" max="255" value="0" class="w-full" data-default="0">
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Mid Point</span> <span id="val-l-mid" class="val-display">1.00</span></div>
                <input id="adj-l-mid" type="range" min="0.0" max="2.0" step="0.01" value="1.0" class="w-full" data-default="1.0">
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>White Point</span> <span id="val-l-white" class="val-display">255</span></div>
                <input id="adj-l-white" type="range" min="0" max="255" value="255" class="w-full" data-default="255">
            </div>
            <div class="drawer-divider"></div>
             <div class="section-header">
                <span class="section-title">Color</span>
                <button id="resetSatBtn" class="section-reset">Reset</button>
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Saturation</span> <span id="val-sat" class="val-display">0</span></div>
                <input id="adj-sat" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
             <div class="drawer-slider-group">
                <div class="drawer-label"><span>Vibrance</span> <span id="val-vib" class="val-display">0</span></div>
                <input id="adj-vib" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
            <div class="drawer-divider"></div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>White Balance</span> <span id="val-wb" class="val-display">6500K</span></div>
                <input id="adj-wb" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
            <div class="drawer-divider"></div>
            <div class="section-header">
                <span class="section-title">Color Balance</span>
                <button id="resetColorBtn" class="section-reset">Reset</button>
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Cyan - Red</span> <span id="val-cb-r" class="val-display">0</span></div>
                <input id="adj-cb-r" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Magenta - Green</span> <span id="val-cb-g" class="val-display">0</span></div>
                <input id="adj-cb-g" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
            <div class="drawer-slider-group">
                <div class="drawer-label"><span>Yellow - Blue</span> <span id="val-cb-b" class="val-display">0</span></div>
                <input id="adj-cb-b" type="range" min="-100" max="100" value="0" class="w-full" data-default="0">
            </div>
        </div>
    </div>

    <!-- Vertical Toolbox (Left) -->
    <div style="top: max(30%, 300px);" class="absolute left-0 transform -translate-y-1/2 bg-gray-900 border-y border-r border-gray-700 rounded-r-lg p-2 flex flex-col gap-2 z-40 shadow-xl">
        <!-- Undo / Redo -->
        <div class="flex flex-col gap-2 border-b border-gray-700 pb-2 mb-1">
            <button id="undoBtn" class="icon-btn" title="Undo (Ctrl+Z)" disabled>
                <img src="icons/undo.svg" alt="Undo" class="w-5 h-5">
            </button>
            <button id="redoBtn" class="icon-btn" title="Redo (Ctrl+Y)" disabled>
                <img src="icons/redo.svg" alt="Redo" class="w-5 h-5">
            </button>
        </div>
        <!-- View Toggles -->
        <div class="flex flex-col gap-2 border-b border-gray-700 pb-2 mb-1">
            <button id="toggleBackBtn" class="icon-btn" title="Toggle Rear Image Visibility">
                <img id="rearEyeOpen" src="icons/back_show.svg" alt="Show Back" class="w-5 h-5">
                <img id="rearEyeClosed" src="icons/back_hide.svg" alt="Hide Back" class="w-5 h-5 hidden">
            </button>
            <button id="toggleMaskBtn" class="icon-btn" title="Toggle Holes Visibility">
                <img id="maskEyeOpen" src="icons/edits_show.svg" alt="Show Edits" class="w-5 h-5">
                <img id="maskEyeClosed" src="icons/edits_hide.svg" alt="Hide Edits" class="w-5 h-5 hidden">
            </button>
        </div>
        
        <!-- Crop Tool -->
        <div class="flex flex-col gap-2 border-b border-gray-700 pb-2 mb-1">
             <button id="cropBtn" class="icon-btn hover:text-yellow-400" title="Crop Canvas">
                <img src="icons/crop.svg" alt="Crop" class="w-5 h-5">
            </button>
        </div>

        <!-- Actions -->
        <button id="swapBtn" class="icon-btn text-blue-400" title="Swap Front/Back">
            <img src="icons/swap.svg" alt="Swap" class="w-5 h-5">
        </button>
        <button id="censorBtn" class="icon-btn text-purple-400" title="Censor (Mosaic+Blur Back)">
            <img src="icons/censor.svg" alt="Censor" class="w-5 h-5">
        </button>
        <button id="mergeBtn" class="icon-btn hover:text-green-400" title="Merge Visible to Slot A">
            <img src="icons/merge.svg" alt="Merge" class="w-5 h-5">
        </button>
        <button id="clearMask" class="icon-btn hover:text-red-400" title="Reset">
            <img src="icons/reset.svg" alt="Reset" class="w-5 h-5">
        </button>
    </div>

    <!-- Top Toolbar -->
    <div class="h-12 bg-gray-900 border-b border-gray-800 flex items-center gap-4 px-4 z-50 shrink-0 overflow-x-auto relative" style="cursor: default;">
        <div class="flex flex-row gap-2 shrink-0">
            <input type="file" id="fileA" accept="image/*" class="hidden">
            <button onclick="document.getElementById('fileA').click()" id="btnA" class="tool-btn px-2 py-1 text-[10px] font-bold rounded border border-gray-600 hover:bg-gray-800 text-gray-300 w-24 truncate leading-tight">
                Load Img A
            </button>
            <input type="file" id="fileB" accept="image/*" class="hidden">
            <button onclick="document.getElementById('fileB').click()" id="btnB" class="tool-btn px-2 py-1 text-[10px] font-bold rounded border border-gray-600 hover:bg-gray-800 text-gray-300 w-24 truncate leading-tight">
                Load Img B
            </button>
        </div>
        <div class="w-px h-6 bg-gray-700 shrink-0"></div>
        <div class="flex items-center gap-4 shrink-0">
            <div class="flex bg-gray-800 rounded p-0.5">
                <button id="eraseMode" class="tool-btn active px-2 py-0.5 rounded text-[10px] font-medium">Erase</button>
                <button id="repairMode" class="tool-btn px-2 py-0.5 rounded text-[10px] font-medium">Repair</button>
            </div>
            <div class="flex flex-col gap-0.5 w-24">
                <div class="flex justify-between text-[10px] text-gray-400">
                    <span>Size (%)</span>
                    <span id="brushSizeVal">10</span>
                </div>
                <input type="range" id="brushSize" min="1" max="30" value="10" class="w-full">
            </div>
            <div class="flex flex-col gap-0.5 w-24">
                <div class="flex justify-between text-[10px] text-gray-400">
                    <span>Hardness</span>
                    <span id="featherVal">95%</span>
                </div>
                <input type="range" id="feather" min="0" max="20" value="1" class="w-full transform rotate-180"> 
            </div>
        </div>
        <div class="w-px h-6 bg-gray-700 shrink-0"></div>
        <div class="flex flex-col gap-0.5 w-24 shrink-0">
            <div class="flex justify-between text-[10px] text-gray-400">
                <span>Opacity</span>
                <span id="opacityVal">80%</span>
            </div>
            <input type="range" id="opacitySlider" min="0" max="100" value="80" class="w-full">
        </div>
        <div class="ml-auto">
            <button id="saveBtn" class="tool-btn flex items-center gap-2 bg-blue-900 hover:bg-blue-800 text-white px-3 py-1.5 rounded shadow text-xs font-medium border border-blue-800" title="Export PNG">
                <img src="icons/export.svg" alt="Export" class="w-4 h-4">
                <span>Export</span>
            </button>
        </div>
    </div>

    <!-- Main Workspace -->
    <div id="canvas-container" class="checkerboard relative w-full flex-grow flex flex-col overflow-hidden">
        <div id="empty-state" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none z-10">
            <div class="text-center">
                <svg class="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                <p class="text-xl font-medium">Load or Drop two images</p>
                <p class="text-sm mt-2 opacity-75">Space to Pan &bull; Wheel to Zoom</p>
            </div>
        </div>
        
        <!-- Dark overlay for workspace when cropping -->
        <div id="backdrop-dimmer"></div>

        <div id="viewport" class="disabled">
            <div id="canvas-wrapper">
                <canvas id="mainCanvas" class="shadow-2xl hidden"></canvas>
                
                <!-- Crop UI Elements (DOM based) -->
                <div id="crop-overlay-dom">
                    <div id="crop-box">
                        <div class="crop-handle handle-nw" data-handle="nw"></div>
                        <div class="crop-handle handle-ne" data-handle="ne"></div>
                        <div class="crop-handle handle-sw" data-handle="sw"></div>
                        <div class="crop-handle handle-se" data-handle="se"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const log = (msg, type = 'error') => {
            console.log(`[${type}] ${msg}`);
            const consoleEl = document.getElementById('error-console');
            const el = document.createElement('div');
            el.className = `console-msg ${type}`;
            el.textContent = msg;
            consoleEl.appendChild(el);
            setTimeout(() => {
                el.style.opacity = '0';
                setTimeout(() => el.remove(), 200);
            }, 6000); 
        };

        let hintTimer = null;
        function showHints() {
            const legend = document.getElementById('hint-legend');
            legend.style.opacity = '1';
            if (hintTimer) clearTimeout(hintTimer);
            hintTimer = setTimeout(() => {
                legend.style.opacity = '0';
            }, 6000);
        }

        const eventHub = (() => {
            const listeners = new Map();
            return {
                on(event, handler) {
                    if (!listeners.has(event)) listeners.set(event, new Set());
                    listeners.get(event).add(handler);
                    return () => this.off(event, handler);
                },
                off(event, handler) {
                    if (listeners.has(event)) listeners.get(event).delete(handler);
                },
                emit(event, payload) {
                    if (!listeners.has(event)) return;
                    listeners.get(event).forEach(fn => fn(payload));
                }
            };
        })();

        const state = {
            imgA: null, imgB: null, nameA: '', nameB: '', isAFront: true, 
            opacity: 0.8, brushPercent: 10, feather: 1, isErasing: true, isDrawing: false,
            maskVisible: true, backVisible: true, history: [], historyIndex: -1, lastActionType: null,
            isSpacePressed: false, isPanning: false, lastPanX: 0, lastPanY: 0, view: { x: 0, y: 0, scale: 1 }, lastSpaceUp: 0,
            isCtrlPressed: false, isPreviewing: false, lastPreviewTime: 0, previewMaskCanvas: null, previewLoopId: null,
            isPolylineStart: false, polylinePoints: [], polylineDirty: false, currentPointerX: null, currentPointerY: null,
            adjustments: { gamma: 1.0, levels: { black: 0, mid: 1.0, white: 255 }, shadows: 0, highlights: 0, saturation: 0, vibrance: 0, wb: 0, colorBal: { r: 0, g: 0, b: 0 } },
            isAdjusting: false, previewCanvas: null, previewFrontLayer: null, previewThrottle: 0,
            isCropping: false, cropRect: null, fullDims: { w: 0, h: 0 }, cropDrag: null
        };

        const els = {
            fileA: document.getElementById('fileA'), fileB: document.getElementById('fileB'),
            btnA: document.getElementById('btnA'), btnB: document.getElementById('btnB'),
            mainCanvas: document.getElementById('mainCanvas'), viewport: document.getElementById('viewport'),
            canvasWrapper: document.getElementById('canvas-wrapper'), emptyState: document.getElementById('empty-state'),
            swapBtn: document.getElementById('swapBtn'), opacitySlider: document.getElementById('opacitySlider'),
            opacityVal: document.getElementById('opacityVal'), brushSize: document.getElementById('brushSize'),
            brushSizeVal: document.getElementById('brushSizeVal'), feather: document.getElementById('feather'),
            featherVal: document.getElementById('featherVal'), eraseMode: document.getElementById('eraseMode'),
            repairMode: document.getElementById('repairMode'), clearMask: document.getElementById('clearMask'),
            saveBtn: document.getElementById('saveBtn'), dragOverlay: document.getElementById('drag-overlay'),
            toggleMaskBtn: document.getElementById('toggleMaskBtn'), maskEyeOpen: document.getElementById('maskEyeOpen'), maskEyeClosed: document.getElementById('maskEyeClosed'),
            toggleBackBtn: document.getElementById('toggleBackBtn'), rearEyeOpen: document.getElementById('rearEyeOpen'), rearEyeClosed: document.getElementById('rearEyeClosed'),
            mergeBtn: document.getElementById('mergeBtn'), censorBtn: document.getElementById('censorBtn'),
            undoBtn: document.getElementById('undoBtn'), redoBtn: document.getElementById('redoBtn'),
            cropBtn: document.getElementById('cropBtn'), cursor: document.getElementById('brush-cursor'),
            resetAdjBtn: document.getElementById('resetAdjBtn'), resetLevelsBtn: document.getElementById('resetLevelsBtn'),
            resetColorBtn: document.getElementById('resetColorBtn'), resetSatBtn: document.getElementById('resetSatBtn'),
            adjGamma: document.getElementById('adj-gamma'), valGamma: document.getElementById('val-gamma'),
            cropOverlayDom: document.getElementById('crop-overlay-dom'), cropBox: document.getElementById('crop-box')
        };

        const ctx = els.mainCanvas.getContext('2d', { willReadFrequently: true });
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
        const frontLayerCanvas = document.createElement('canvas');
        const frontLayerCtx = frontLayerCanvas.getContext('2d');

        function loadFilesModule() {
            return new Promise((resolve, reject) => {
                if (window.filesModule?.init) {
                    resolve(window.filesModule);
                    return;
                }
                const script = document.createElement('script');
                script.src = 'files.js';
                script.onload = () => resolve(window.filesModule);
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function bootstrapFileModule() {
            loadFilesModule()
                .then((mod) => {
                    if (!mod?.init) throw new Error('files module missing init');
                    mod.init({
                        state,
                        els,
                        canvases: { maskCanvas, maskCtx, frontLayerCanvas, frontLayerCtx },
                        helpers: { updateCanvasDimensions, updateUI, truncate, resizeMainCanvas, resetMaskOnly, log, canDraw },
                        eventHub
                    });
                })
                .catch((err) => {
                    console.error(err);
                    log('File module failed to load');
                });
        }

        let gammaLUT = new Uint8Array(256);
        let currentGammaLUTValue = -1;
        let masterLUT = new Uint8Array(256);
        let currentLUTHash = "";

        function getCurvedValue(sliderVal) {
            const abs = Math.abs(sliderVal);
            const sign = Math.sign(sliderVal);
            let effective = 0;
            if (abs <= 80) effective = (abs / 80) * 50;
            else effective = 50 + ((abs - 80) / 20) * 50;
            return Math.round(sign * effective);
        }

        function updateMasterLUT() {
            const g = state.adjustments.gamma;
            const l = state.adjustments.levels;
            const hash = `${g}-${l.black}-${l.mid}-${l.white}`;
            if (hash === currentLUTHash) return;
            const invGamma = 1 / g; 
            const invMid = 1 / l.mid;
            const blackNorm = l.black / 255;
            const whiteNorm = l.white / 255;
            const range = whiteNorm - blackNorm;
            for (let i = 0; i < 256; i++) {
                let n = i / 255;
                if (range <= 0.001) n = (n > blackNorm) ? 1.0 : 0.0;
                else n = (n - blackNorm) / range;
                if (n < 0) n = 0; if (n > 1) n = 1;
                n = Math.pow(n, invMid);
                n = Math.pow(n, invGamma);
                if (n < 0) n = 0; if (n > 1) n = 1;
                masterLUT[i] = n * 255;
            }
            currentLUTHash = hash;
        }

        function applyMasterLUT(imageData) {
            const data = imageData.data;
            const g = state.adjustments.gamma;
            const l = state.adjustments.levels;
            if (Math.abs(g - 1.0) < 0.01 && l.black === 0 && Math.abs(l.mid - 1.0) < 0.01 && l.white === 255) return;
            updateMasterLUT();
            for (let i = 0; i < data.length; i += 4) {
                data[i] = masterLUT[data[i]]; data[i+1] = masterLUT[data[i+1]]; data[i+2] = masterLUT[data[i+2]]; 
            }
        }

        function applyColorOps(imageData) {
            const a = state.adjustments;
            const sat = a.saturation; const vib = a.vibrance; const wb = a.wb;
            const shad = a.shadows; const high = a.highlights;
            const crSlider = a.colorBal.r; const cgSlider = a.colorBal.g; const cbSlider = a.colorBal.b;
            if (sat === 0 && vib === 0 && wb === 0 && shad === 0 && high === 0 && crSlider === 0 && cgSlider === 0 && cbSlider === 0) return;
            const data = imageData.data;
            const satMult = 1 + (sat / 100);
            const cr = getCurvedValue(crSlider); const cg = getCurvedValue(cgSlider); const cb = getCurvedValue(cbSlider);
            const wbR = wb > 0 ? 1 + (wb/200) : 1 - (Math.abs(wb)/400); 
            const wbB = wb < 0 ? 1 + (Math.abs(wb)/200) : 1 - (wb/400);

            for (let i = 0; i < data.length; i += 4) {
                let r = data[i]; let g = data[i+1]; let b = data[i+2];
                const lum = 0.299*r + 0.587*g + 0.114*b;
                const normLum = lum / 255;
                if (shad !== 0 || high !== 0) {
                    if (shad !== 0) {
                         const sFactor = (1.0 - normLum) * (1.0 - normLum);
                         const sMult = 1 + (shad / 100) * sFactor;
                         r *= sMult; g *= sMult; b *= sMult;
                    }
                    if (high !== 0) {
                         const hFactor = normLum * normLum;
                         const hMult = 1 + (high / 100) * hFactor;
                         r *= hMult; g *= hMult; b *= hMult;
                    }
                }
                if (sat !== 0 || vib !== 0) {
                    const gray = 0.299*r + 0.587*g + 0.114*b;
                    if (sat !== 0) {
                        r = gray + (r - gray) * satMult;
                        g = gray + (g - gray) * satMult;
                        b = gray + (b - gray) * satMult;
                    }
                    if (vib !== 0) {
                        const max = Math.max(r, g, b);
                        const satVal = (max - gray) / 255; 
                        const vMult = (vib / 100) * 2.0 * (1 - satVal); 
                        const scale = 1 + vMult;
                        r = gray + (r - gray) * scale;
                        g = gray + (g - gray) * scale;
                        b = gray + (b - gray) * scale;
                    }
                }
                if (wb !== 0) {
                    const oldLum = 0.299*r + 0.587*g + 0.114*b;
                    r *= wbR; b *= wbB;
                    const newLum = 0.299*r + 0.587*g + 0.114*b;
                    if (newLum > 0.01) {
                         const scale = oldLum / newLum;
                         r *= scale; g *= scale; b *= scale;
                    }
                }
                if (cr !== 0 || cg !== 0 || cb !== 0) {
                    const oldLum = 0.299*r + 0.587*g + 0.114*b;
                    r += cr; g += cg; b += cb;
                    const rClamped = Math.max(0, r); const gClamped = Math.max(0, g); const bClamped = Math.max(0, b);
                    const newLum = 0.299*rClamped + 0.587*gClamped + 0.114*bClamped;
                    if (newLum > 0.01) {
                        const scale = oldLum / newLum;
                        r = rClamped * scale; g = gClamped * scale; b = bClamped * scale;
                    } else {
                        r = Math.max(0, r); g = Math.max(0, g); b = Math.max(0, b);
                    }
                }
                data[i] = Math.min(255, Math.max(0, r));
                data[i+1] = Math.min(255, Math.max(0, g));
                data[i+2] = Math.min(255, Math.max(0, b));
            }
        }

        function updateAdjustmentPreview() {
            if (!state.imgA && !state.imgB) return;
            const now = Date.now();
            if (now - state.previewThrottle < 100) return; 
            state.previewThrottle = now;
            if (!state.previewCanvas) state.previewCanvas = document.createElement('canvas');
            if (!state.previewFrontLayer) state.previewFrontLayer = document.createElement('canvas');
            
            // Adjust to use current view size (cropped or full)
            const w = els.mainCanvas.width;
            const h = els.mainCanvas.height;
            const scale = Math.min(1, 1920 / Math.max(w, h));
            const pw = Math.floor(w * scale);
            const ph = Math.floor(h * scale);

            if (state.previewCanvas.width !== pw || state.previewCanvas.height !== ph) {
                state.previewCanvas.width = pw;
                state.previewCanvas.height = ph;
                state.previewFrontLayer.width = pw;
                state.previewFrontLayer.height = ph;
            }
            const pCtx = state.previewCanvas.getContext('2d');
            renderToContext(pCtx, pw, ph, true); 
            const imgData = pCtx.getImageData(0, 0, pw, ph);
            applyMasterLUT(imgData); 
            applyColorOps(imgData);  
            pCtx.putImageData(imgData, 0, 0);
            ctx.clearRect(0, 0, w, h);
            ctx.imageSmoothingEnabled = false; 
            ctx.globalAlpha = 1.0; 
            ctx.drawImage(state.previewCanvas, 0, 0, w, h);
            ctx.imageSmoothingEnabled = true;
        }

        function init() {
            initAdjustments();
            window.addEventListener('pointerup', () => {
                if(state.isAdjusting) {
                    state.isAdjusting = false;
                    render();
                }
            });
            els.opacitySlider.addEventListener('input', (e) => {
                state.opacity = e.target.value / 100;
                els.opacityVal.textContent = Math.round(state.opacity * 100) + '%';
                render();
            });
            els.brushSize.addEventListener('input', (e) => {
                state.brushPercent = parseInt(e.target.value);
                els.brushSizeVal.textContent = state.brushPercent;
                updateCursorSize();
            });
            els.feather.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                state.feather = val; 
                const hardness = Math.round(100 - (val / 20 * 100));
                els.featherVal.textContent = hardness + '%';
            });
            els.eraseMode.addEventListener('click', () => setMode(true));
            els.repairMode.addEventListener('click', () => setMode(false));
            
            els.clearMask.addEventListener('click', () => {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                resetAllAdjustments();
                saveSnapshot('full_reset');
                resetView();
                render();
                log("Reset All", "info");
            });

            bootstrapFileModule();
            els.undoBtn.addEventListener('click', undo);
            els.redoBtn.addEventListener('click', redo);
            
            els.cropBtn.addEventListener('click', toggleCropMode);

            els.toggleMaskBtn.addEventListener('click', () => {
                state.maskVisible = !state.maskVisible;
                els.maskEyeOpen.classList.toggle('hidden');
                els.maskEyeClosed.classList.toggle('hidden');
                render();
            });
            els.toggleBackBtn.addEventListener('click', () => {
                state.backVisible = !state.backVisible;
                els.rearEyeOpen.classList.toggle('hidden');
                els.rearEyeClosed.classList.toggle('hidden');
                render();
            });

            els.viewport.addEventListener('pointerdown', handlePointerDown);
            window.addEventListener('pointermove', handlePointerMove);
            window.addEventListener('pointerup', handlePointerUp);
            els.viewport.addEventListener('wheel', handleWheel, { passive: false });
            els.viewport.addEventListener('contextmenu', e => e.preventDefault());

            window.addEventListener('keydown', (e) => {
                showHints(); 
                if (e.code === 'Space' && !e.repeat) {
                    e.preventDefault(); 
                    state.isSpacePressed = true;
                    updateCursorStyle();
                    const now = Date.now();
                    if (now - state.lastSpaceUp < 250) resetView();
                }
                if ((e.ctrlKey || e.metaKey) && !e.repeat && !state.isCropping) {
                    state.isCtrlPressed = true;
                    state.isPolylineStart = true;
                    state.lastDrawX = null;
                    state.polylinePoints = []; 
                    state.polylineDirty = false; 
                    startPreviewLoop();
                }
                if (e.key === '[' || e.key === ']') {
                    const delta = e.key === '[' ? -1 : 1;
                    let newSize = state.brushPercent + delta;
                    newSize = Math.max(1, Math.min(30, newSize));
                    state.brushPercent = newSize;
                    els.brushSize.value = newSize;
                    els.brushSizeVal.textContent = newSize;
                    updateCursorSize();
                }
                if ((e.ctrlKey || e.metaKey)) {
                    if (e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
                    else if (e.key === 'y') { e.preventDefault(); redo(); }
                }
            });

            window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    state.isSpacePressed = false;
                    state.isPanning = false; 
                    state.lastSpaceUp = Date.now();
                    updateCursorStyle();
                }
                if (e.key === 'Control' || e.key === 'Meta') {
                    if (state.polylineDirty) {
                        saveSnapshot('mask');
                        state.polylineDirty = false;
                    }
                    state.isCtrlPressed = false;
                    state.isPreviewing = false;
                    state.isPolylineStart = false; 
                    state.lastDrawX = null; 
                    state.polylinePoints = []; 
                    stopPreviewLoop();
                    render(); 
                }
            });
            
            log("Ready. Load images to begin.", "info");
            showHints(); 
        }

        // --- Adjustment UI Logic ---
        function initAdjustments() {
            function attach(id, key, subkey, type='float') {
                const el = document.getElementById(id);
                const label = document.getElementById('val-' + id.replace('adj-', ''));
                if(!el) return;
                
                el.addEventListener('input', (e) => {
                    let val = parseFloat(e.target.value);
                    if (subkey) state.adjustments[key][subkey] = val;
                    else state.adjustments[key] = val;

                    if (type === 'curve') label.textContent = getCurvedValue(val);
                    else if (type === 'float') label.textContent = val.toFixed(2);
                    else if (type === 'K') label.textContent = (6500 + val*30) + 'K';
                    else label.textContent = val;

                    state.isAdjusting = true;
                    updateAdjustmentPreview();
                });

                el.addEventListener('change', (e) => {
                    state.isAdjusting = false;
                    saveSnapshot('adjustment');
                    render();
                });
            }

            attach('adj-gamma', 'gamma');
            attach('adj-shadows', 'shadows', null, 'int');
            attach('adj-highlights', 'highlights', null, 'int');
            attach('adj-l-black', 'levels', 'black', 'int');
            attach('adj-l-mid', 'levels', 'mid', 'float');
            attach('adj-l-white', 'levels', 'white', 'int');
            attach('adj-sat', 'saturation', null, 'int');
            attach('adj-vib', 'vibrance', null, 'int');
            attach('adj-wb', 'wb', null, 'K');
            attach('adj-cb-r', 'colorBal', 'r', 'curve');
            attach('adj-cb-g', 'colorBal', 'g', 'curve');
            attach('adj-cb-b', 'colorBal', 'b', 'curve');

            els.resetAdjBtn.addEventListener('click', () => {
                const a = state.adjustments;
                if (a.gamma === 1.0 && a.levels.black === 0 && a.levels.mid === 1.0 && a.levels.white === 255 &&
                    a.saturation === 0 && a.vibrance === 0 && a.wb === 0 && 
                    a.colorBal.r === 0 && a.colorBal.g === 0 && a.colorBal.b === 0 &&
                    a.shadows === 0 && a.highlights === 0) return;

                resetAllAdjustments();
                saveSnapshot('adjustments_reset');
                render();
            });

            els.resetLevelsBtn.addEventListener('click', () => {
                const l = state.adjustments.levels;
                if (l.black === 0 && l.mid === 1.0 && l.white === 255) return;
                state.adjustments.levels = { black: 0, mid: 1.0, white: 255 };
                updateSlider('adj-l-black', 0);
                updateSlider('adj-l-mid', 1.0);
                updateSlider('adj-l-white', 255);
                saveSnapshot('levels_reset');
                render();
            });

            document.getElementById('resetSatBtn').addEventListener('click', () => {
                 if (state.adjustments.saturation === 0 && state.adjustments.vibrance === 0) return;
                 state.adjustments.saturation = 0;
                 state.adjustments.vibrance = 0;
                 updateSlider('adj-sat', 0);
                 updateSlider('adj-vib', 0);
                 saveSnapshot('sat_reset');
                 render();
            });
            
            els.resetColorBtn.addEventListener('click', () => {
                 const a = state.adjustments;
                 if (a.wb === 0 && a.colorBal.r === 0 && a.colorBal.g === 0 && a.colorBal.b === 0) return;
                 state.adjustments.wb = 0;
                 state.adjustments.colorBal = { r:0, g:0, b:0 };
                 updateSlider('adj-wb', 0);
                 updateSlider('adj-cb-r', 0);
                 updateSlider('adj-cb-g', 0);
                 updateSlider('adj-cb-b', 0);
                 saveSnapshot('color_reset');
                 render();
            });
        }

        function resetAllAdjustments() {
             state.adjustments = { 
                 gamma: 1.0, 
                 levels: { black: 0, mid: 1.0, white: 255 },
                 saturation: 0, vibrance: 0,
                 wb: 0, colorBal: { r:0, g:0, b:0 },
                 shadows: 0, highlights: 0
             };
             updateSlider('adj-gamma', 1.0);
             updateSlider('adj-l-black', 0);
             updateSlider('adj-l-mid', 1.0);
             updateSlider('adj-l-white', 255);
             updateSlider('adj-sat', 0);
             updateSlider('adj-vib', 0);
             updateSlider('adj-wb', 0);
             updateSlider('adj-cb-r', 0);
             updateSlider('adj-cb-g', 0);
             updateSlider('adj-cb-b', 0);
             updateSlider('adj-shadows', 0);
             updateSlider('adj-highlights', 0);
        }

        function updateSlider(id, val) {
            const el = document.getElementById(id);
            if(el) {
                el.value = val;
                const label = document.getElementById('val-' + id.replace('adj-', ''));
                if (label) {
                     if (id.startsWith('adj-cb')) label.textContent = getCurvedValue(val);
                     else if (id === 'adj-wb') label.textContent = (6500 + val*30) + 'K';
                     else if (el.step === '0.01' || el.step === '0.1') label.textContent = parseFloat(val).toFixed(2);
                     else label.textContent = val;
                }
            }
        }

        // --- Core Rendering & Helper ---
        function renderToContext(targetCtx, w, h, forceOpacity = false) {
            targetCtx.clearRect(0, 0, w, h);

            const frontImg = state.isAFront ? state.imgA : state.imgB;
            const backImg = state.isAFront ? state.imgB : state.imgA;
            
            // Adjust draw args for crop logic
            const sX = state.isCropping ? 0 : state.cropRect.x;
            const sY = state.isCropping ? 0 : state.cropRect.y;
            const sW = state.isCropping ? state.fullDims.w : state.cropRect.w;
            const sH = state.isCropping ? state.fullDims.h : state.cropRect.h;

            // Draw Back
            if (backImg && state.backVisible) {
                targetCtx.globalAlpha = 1.0;
                targetCtx.globalCompositeOperation = 'source-over';
                
                const scale = state.fullDims.h / backImg.height; 
                const backW = backImg.width * scale;
                const backH = state.fullDims.h;
                const backX = (state.fullDims.w - backW) / 2;
                
                const bSrcX = (sX - backX) / scale;
                const bSrcY = sY / scale;
                const bSrcW = sW / scale;
                const bSrcH = sH / scale;
                
                targetCtx.drawImage(backImg, bSrcX, bSrcY, bSrcW, bSrcH, 0, 0, w, h);
            }

            // Draw Front
            if (frontImg) {
                const fCtx = state.previewFrontLayer.getContext('2d');
                fCtx.clearRect(0, 0, w, h);
                
                fCtx.globalCompositeOperation = 'source-over';
                fCtx.drawImage(frontImg, sX, sY, sW, sH, 0, 0, w, h);

                if (state.maskVisible) {
                    fCtx.globalCompositeOperation = 'destination-out';
                    fCtx.drawImage(maskCanvas, sX, sY, sW, sH, 0, 0, w, h);
                }
                
                targetCtx.globalCompositeOperation = 'source-over';
                // Use forceOpacity for adjustments preview (so we see true pixels)
                const effectiveOpacity = (!state.backVisible || forceOpacity) ? 1.0 : state.opacity;
                targetCtx.globalAlpha = effectiveOpacity; 
                targetCtx.drawImage(state.previewFrontLayer, 0, 0);
            }
        }
        
        function render(finalOutput = false, skipAdjustments = false) {
            if (state.isAdjusting && !finalOutput) {
                 if (Date.now() - state.previewThrottle > 500) state.isAdjusting = false;
                 else return;
            }

            const cw = els.mainCanvas.width;
            const ch = els.mainCanvas.height;
            
            ctx.clearRect(0, 0, cw, ch);
            
            // If cropping, draw full source image, then overlay
            // When !isCropping, the main canvas is sized to cropRect, so sX/Y is just cropRect.x/y
            const sX = state.isCropping ? 0 : state.cropRect.x;
            const sY = state.isCropping ? 0 : state.cropRect.y;
            const sW = state.isCropping ? state.fullDims.w : state.cropRect.w;
            const sH = state.isCropping ? state.fullDims.h : state.cropRect.h;

            const frontImg = state.isAFront ? state.imgA : state.imgB;
            const backImg = state.isAFront ? state.imgB : state.imgA;

            // 1. Draw Back
            const shouldRenderBack = backImg && (state.backVisible || finalOutput);

            if (shouldRenderBack) {
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
                
                const scale = state.fullDims.h / backImg.height;
                const backW = backImg.width * scale;
                const backH = state.fullDims.h;
                const backX = (state.fullDims.w - backW) / 2;
                
                // Mapping crop rect to back image source rect
                const bSrcX = (sX - backX) / scale;
                const bSrcY = sY / scale;
                const bSrcW = sW / scale;
                const bSrcH = sH / scale;
                
                ctx.drawImage(backImg, bSrcX, bSrcY, bSrcW, bSrcH, 0, 0, cw, ch);
            }

            // 2. Prepare Front Layer
            if (frontImg) {
                frontLayerCtx.clearRect(0, 0, cw, ch);
                frontLayerCtx.globalCompositeOperation = 'source-over';
                // Draw clipped portion of front image
                frontLayerCtx.drawImage(frontImg, sX, sY, sW, sH, 0, 0, cw, ch);

                let maskSource = maskCanvas;
                if (state.isPreviewing && state.previewMaskCanvas) {
                    maskSource = state.previewMaskCanvas;
                }

                if (state.maskVisible) {
                    frontLayerCtx.globalCompositeOperation = 'destination-out';
                    if (state.isPreviewing && state.previewMaskCanvas) {
                         // Scale logic for preview mask not needed here since we render 1:1 on main canvas usually
                         // But we need to clip the mask too
                         frontLayerCtx.drawImage(maskSource, sX, sY, sW, sH, 0, 0, cw, ch);
                    } else {
                         frontLayerCtx.drawImage(maskSource, sX, sY, sW, sH, 0, 0, cw, ch);
                    }
                }
                
                // 3. Composite Front to Main
                frontLayerCtx.globalCompositeOperation = 'source-over';
                const effectiveOpacity = (finalOutput || !state.backVisible) ? 1.0 : state.opacity;
                ctx.globalAlpha = effectiveOpacity;
                ctx.drawImage(frontLayerCanvas, 0, 0);
            }
            
            // 4. Update Crop DOM Overlay
            if (state.isCropping) {
                els.cropOverlayDom.style.display = 'block';
                const r = state.cropRect;
                els.cropBox.style.left = r.x + 'px';
                els.cropBox.style.top = r.y + 'px';
                els.cropBox.style.width = r.w + 'px';
                els.cropBox.style.height = r.h + 'px';
                
                const invScale = 1 / state.view.scale;
                document.querySelectorAll('.crop-handle').forEach(el => {
                    el.style.setProperty('--inv-scale', invScale);
                });
            } else {
                els.cropOverlayDom.style.display = 'none';
            }
            
            // 5. Apply Global Adjustments (Non-Destructive) - Only if NOT cropping (cropping shows raw)
            const a = state.adjustments;
            const needsAdj = a.gamma !== 1.0 || a.levels.black !== 0 || a.levels.mid !== 1.0 || a.levels.white !== 255 || 
                             a.saturation !== 0 || a.vibrance !== 0 || a.wb !== 0 ||
                             a.colorBal.r !== 0 || a.colorBal.g !== 0 || a.colorBal.b !== 0 ||
                             a.shadows !== 0 || a.highlights !== 0;

            if (needsAdj && !skipAdjustments && !state.isCropping) {
                const imgData = ctx.getImageData(0, 0, cw, ch);
                applyMasterLUT(imgData);
                applyColorOps(imgData);
                ctx.putImageData(imgData, 0, 0);
            }
        }

        eventHub.on('history-save', (actionType) => saveSnapshot(actionType));
        eventHub.on('render-request', (options = {}) => {
            const finalOutput = options?.final ?? false;
            const skipAdjustments = options?.skipAdjustments ?? false;
            render(finalOutput, skipAdjustments);
        });

        // --- Crop Logic ---
        function toggleCropMode() {
            if (!canDraw()) return;
            state.isCropping = !state.isCropping;
            
            if (state.isCropping) {
                els.cropBtn.classList.add('active', 'text-yellow-400');
                // Resize main canvas to full dims
                resizeMainCanvas(state.fullDims.w, state.fullDims.h);
                els.viewport.classList.add('cropping');
            } else {
                els.cropBtn.classList.remove('active', 'text-yellow-400');
                // Resize main canvas to crop rect
                resizeMainCanvas(state.cropRect.w, state.cropRect.h);
                els.viewport.classList.remove('cropping');
            }
            resetView();
            render();
            updateUI(); // disable other tools
        }

        function resizeMainCanvas(w, h) {
            els.mainCanvas.width = w;
            els.mainCanvas.height = h;
            frontLayerCanvas.width = w;
            frontLayerCanvas.height = h;
        }

        // --- History Logic Updated ---
        function saveSnapshot(actionType = 'generic') {
            const snap = {
                mask: maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height),
                adjustments: JSON.parse(JSON.stringify(state.adjustments)),
                cropRect: { ...state.cropRect } // Add crop to history
            };

            if (actionType !== 'generic' && actionType === state.lastActionType) {
                state.history[state.historyIndex] = snap;
            } else {
                if (state.historyIndex < state.history.length - 1) {
                    state.history = state.history.slice(0, state.historyIndex + 1);
                }
                if (state.history.length > 30) state.history.shift();
                state.history.push(snap);
                state.historyIndex = state.history.length - 1;
            }
            state.lastActionType = actionType;
            updateUI(); 
        }

        function resetMaskAndHistory() {
             maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
             state.history = [];
             state.historyIndex = -1;
             resetAllAdjustments();
             state.lastActionType = null;
             // Reset Crop
             if (state.fullDims.w > 0) {
                 state.cropRect = { x: 0, y: 0, w: state.fullDims.w, h: state.fullDims.h };
             }
             saveSnapshot('init');
        }
        
        function resetMaskOnly() {
             maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
             state.history = [];
             state.historyIndex = -1;
             state.lastActionType = null;
             // Don't reset crop rect unless image size changed significantly? 
             // Merge re-inits image data, so it resets state.fullDims.
             saveSnapshot('merge_init');
        }

        function restoreState(snapshot) {
            maskCtx.putImageData(snapshot.mask, 0, 0);
            state.adjustments = JSON.parse(JSON.stringify(snapshot.adjustments));
            state.cropRect = { ...snapshot.cropRect };
            
            updateSlider('adj-gamma', state.adjustments.gamma);
            updateSlider('adj-l-black', state.adjustments.levels.black);
            updateSlider('adj-l-mid', state.adjustments.levels.mid);
            updateSlider('adj-l-white', state.adjustments.levels.white);
            updateSlider('adj-sat', state.adjustments.saturation);
            updateSlider('adj-vib', state.adjustments.vibrance);
            updateSlider('adj-wb', state.adjustments.wb);
            updateSlider('adj-cb-r', state.adjustments.colorBal.r);
            updateSlider('adj-cb-g', state.adjustments.colorBal.g);
            updateSlider('adj-cb-b', state.adjustments.colorBal.b);
            updateSlider('adj-shadows', state.adjustments.shadows);
            updateSlider('adj-highlights', state.adjustments.highlights);
            
            // Restore View context based on crop mode
            if (!state.isCropping) {
                resizeMainCanvas(state.cropRect.w, state.cropRect.h);
                // resetView(); // optional to force fit? maybe jarring.
            } else {
                resizeMainCanvas(state.fullDims.w, state.fullDims.h);
            }

            render();
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                restoreState(state.history[state.historyIndex]);
                updateUI();
                log("Undo", "info");
            }
        }
        
        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                restoreState(state.history[state.historyIndex]);
                updateUI();
                log("Redo", "info");
            }
        }

        // --- Standard App Functions ---
        
        function updateUI() {
            const enable = canDraw();
            els.mergeBtn.disabled = !enable;
            els.censorBtn.disabled = !state.imgA && !state.imgB;
            els.undoBtn.disabled = state.historyIndex <= 0;
            els.redoBtn.disabled = state.historyIndex >= state.history.length - 1;
            
            // Disable tools while cropping
            if (state.isCropping) {
                 els.eraseMode.disabled = true;
                 els.repairMode.disabled = true;
                 els.brushSize.disabled = true;
                 els.censorBtn.disabled = true;
                 els.mergeBtn.disabled = true;
            } else {
                 els.eraseMode.disabled = false;
                 els.repairMode.disabled = false;
                 els.brushSize.disabled = false;
            }

            if(state.isAFront) {
                els.swapBtn.classList.remove('bg-blue-900', 'border-blue-500');
                els.swapBtn.classList.add('bg-gray-800', 'border-gray-600');
            } else {
                els.swapBtn.classList.add('bg-blue-900', 'border-blue-500');
                els.swapBtn.classList.remove('bg-gray-800', 'border-gray-600');
            }
            
            if (enable) {
                els.viewport.classList.remove('disabled');
            } else {
                els.viewport.classList.add('disabled');
                els.cursor.style.display = 'none';
            }
        }

        function truncate(str) {
            if(str.length > 8) return str.substring(0, 6) + '..';
            return str;
        }

        function setMode(isErasing) {
            state.isErasing = isErasing;
            if(isErasing) {
                els.eraseMode.classList.add('active');
                els.repairMode.classList.remove('active');
            } else {
                els.eraseMode.classList.remove('active');
                els.repairMode.classList.add('active');
            }
        }

        function updateCanvasDimensions(preserveView = false) {
            if (!state.imgA && !state.imgB) return;
            const frontImg = state.isAFront ? state.imgA : state.imgB;
            const activeImg = frontImg || (state.isAFront ? state.imgB : state.imgA);
            if (!activeImg) return;
            const targetW = activeImg.width;
            const targetH = activeImg.height;
            
            // Set Full Dims
            state.fullDims = { w: targetW, h: targetH };
            if (!preserveView || !state.cropRect) {
                 state.cropRect = { x: 0, y: 0, w: targetW, h: targetH };
            }

            if (maskCanvas.width !== targetW || maskCanvas.height !== targetH) {
                maskCanvas.width = targetW;
                maskCanvas.height = targetH;
                maskCtx.clearRect(0,0,targetW,targetH); 
                resetMaskAndHistory(); 
            }

            resizeMainCanvas(state.cropRect.w, state.cropRect.h);

            els.mainCanvas.classList.remove('hidden');
            els.emptyState.style.display = 'none';
            els.canvasWrapper.style.width = state.cropRect.w + 'px';
            els.canvasWrapper.style.height = state.cropRect.h + 'px';
            
            if (!preserveView) resetView(); 
        }

        function resetView() {
            // Relaxed check: allow view manipulation with just one image
            if (!state.imgA && !state.imgB) return;
            const vpW = els.viewport.clientWidth;
            const vpH = els.viewport.clientHeight;
            const cW = els.mainCanvas.width;
            const cH = els.mainCanvas.height;
            const scale = Math.min((vpW - 40) / cW, (vpH - 40) / cH);
            const x = (vpW - cW * scale) / 2;
            const y = (vpH - cH * scale) / 2;
            state.view = { x, y, scale };
            updateViewTransform();
        }

        function updateViewTransform() {
            els.canvasWrapper.style.transform = `translate(${state.view.x}px, ${state.view.y}px) scale(${state.view.scale})`;
            updateCursorSize();
        }

        function updateCursorSize() {
            if(!canDraw()) return;
            const visualSize = getBrushPixelSize() * state.view.scale;
            els.cursor.style.width = visualSize + 'px';
            els.cursor.style.height = visualSize + 'px';
        }

        function updateCursorPos(e) {
            if (!canDraw() || state.isPanning || state.isSpacePressed || state.isCropping) {
                els.cursor.style.display = 'none';
                return;
            }
            const rect = els.viewport.getBoundingClientRect();
            if (e.clientX >= rect.left && e.clientX <= rect.right && 
                e.clientY >= rect.top && e.clientY <= rect.bottom) {
                els.cursor.style.display = 'block';
                els.cursor.style.left = e.clientX + 'px';
                els.cursor.style.top = e.clientY + 'px';
            } else {
                els.cursor.style.display = 'none';
            }
        }

        function getCanvasCoordinates(e) {
            const rect = els.viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Canvas coordinates in current display canvas (could be cropped)
            const canvasX = (mouseX - state.view.x) / state.view.scale;
            const canvasY = (mouseY - state.view.y) / state.view.scale;
            
            // If NOT cropping, we need to add the offset
            if (!state.isCropping) {
                 // Check if cropRect exists
                 if (state.cropRect) {
                     return { x: canvasX + state.cropRect.x, y: canvasY + state.cropRect.y };
                 }
            }
            return { x: canvasX, y: canvasY };
        }

        function canDraw() { return (state.imgA || state.imgB) && state.cropRect; }
        function getBrushPixelSize() {
            if (state.fullDims.h === 0) return 20;
            return (state.brushPercent / 100) * state.fullDims.h;
        }

        // --- Drawing / Input Logic ---
        
        function handlePointerDown(e) {
            if (!canDraw()) return;
            const coords = getCanvasCoordinates(e);
            state.currentPointerX = coords.x;
            state.currentPointerY = coords.y;

            if (state.isSpacePressed || e.button === 1) { 
                state.isPanning = true;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                updateCursorStyle();
                return;
            } 
            
            // Crop Interaction with DOM
            // Mouse events on crop handles/box are handled by DOM listeners below to be cleaner
            if (state.isCropping) return;

            if (e.button === 0 && !state.isCropping) {
                if (state.isCtrlPressed) {
                    // Polyline
                    if (state.isPolylineStart) {
                        state.lastDrawX = coords.x;
                        state.lastDrawY = coords.y;
                        state.isPolylineStart = false; 
                        state.polylinePoints = [{x: coords.x, y: coords.y}]; 
                    } else {
                        // Loop Check
                        const threshold = getBrushPixelSize();
                        const startPt = state.polylinePoints[0];
                        const dist = Math.hypot(coords.x - startPt.x, coords.y - startPt.y);
                        
                        if (state.polylinePoints.length > 2 && dist < threshold) {
                            // Close Loop
                            drawStrokeDistance(coords.x, coords.y);
                            state.polylinePoints.push({x: coords.x, y: coords.y});
                            state.lastDrawX = coords.x; 
                            state.lastDrawY = coords.y;
                            drawStrokeDistance(startPt.x, startPt.y);
                            maskCtx.beginPath();
                            maskCtx.moveTo(state.polylinePoints[0].x, state.polylinePoints[0].y);
                            for(let i=1; i<state.polylinePoints.length; i++) maskCtx.lineTo(state.polylinePoints[i].x, state.polylinePoints[i].y);
                            maskCtx.closePath();
                            if (state.isErasing) {
                                maskCtx.globalCompositeOperation = 'source-over';
                                maskCtx.fillStyle = 'white';
                            } else {
                                maskCtx.globalCompositeOperation = 'destination-out';
                                maskCtx.fillStyle = 'black';
                            }
                            maskCtx.fill();
                            state.isPolylineStart = true;
                            state.polylinePoints = [];
                            state.lastDrawX = null;
                            saveSnapshot('draw');
                            state.polylineDirty = false; 
                            render();
                            return;
                        }
                        if(state.polylinePoints.length === 1) drawBrushStamp(state.lastDrawX, state.lastDrawY);
                        drawStrokeDistance(coords.x, coords.y); 
                        state.lastDrawX = coords.x;
                        state.lastDrawY = coords.y;
                        state.polylinePoints.push({x: coords.x, y: coords.y});
                        state.polylineDirty = true; 
                    }
                    render();
                    return;
                }

                state.isDrawing = true;
                state.lastDrawX = null;
                state.lastDrawY = null;
                drawBrushStamp(coords.x, coords.y);
                state.lastDrawX = coords.x;
                state.lastDrawY = coords.y;
                render();
            }
        }

        // DOM Crop Listeners
        const cropHandlers = () => {
             const getScale = () => state.view.scale;
             const handles = document.querySelectorAll('.crop-handle');
             let dragStart = null;
             
             handles.forEach(h => {
                 h.addEventListener('pointerdown', (e) => {
                     e.stopPropagation();
                     const rect = els.viewport.getBoundingClientRect();
                     // Mouse X in canvas space (full image space because mainCanvas = full size in crop mode)
                     const mx = (e.clientX - rect.left - state.view.x) / state.view.scale;
                     const my = (e.clientY - rect.top - state.view.y) / state.view.scale;
                     state.cropDrag = { type: 'handle', h: h.dataset.handle };
                 });
             });
             
             els.cropBox.addEventListener('pointerdown', (e) => {
                 if (e.target !== els.cropBox) return; // ignore handles
                 e.stopPropagation();
                 const rect = els.viewport.getBoundingClientRect();
                 const mx = (e.clientX - rect.left - state.view.x) / state.view.scale;
                 const my = (e.clientY - rect.top - state.view.y) / state.view.scale;
                 state.cropDrag = { 
                     type: 'box', 
                     startX: mx, 
                     startY: my, 
                     startRect: { ...state.cropRect } 
                 };
             });
        }
        // Call in init
        
        function handlePointerMove(e) {
            updateCursorPos(e);
            if (!state.cropRect) return; 
            const coords = getCanvasCoordinates(e);
            state.currentPointerX = coords.x;
            state.currentPointerY = coords.y;

            if (state.isPanning) {
                const dx = e.clientX - state.lastPanX;
                const dy = e.clientY - state.lastPanY;
                let newX = state.view.x + dx;
                let newY = state.view.y + dy;
                // Boundaries relative to viewport size
                const overlap = 50;
                const vpW = els.viewport.clientWidth;
                const vpH = els.viewport.clientHeight;
                // Width depends on current canvas size (crop vs full)
                const cW = els.mainCanvas.width * state.view.scale;
                const cH = els.mainCanvas.height * state.view.scale;

                if (newX > vpW - overlap) newX = vpW - overlap;
                if (newX < overlap - cW) newX = overlap - cW;
                if (newY > vpH - overlap) newY = vpH - overlap;
                if (newY < overlap - cH) newY = overlap - cH;

                state.view.x = newX;
                state.view.y = newY;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                updateViewTransform();
            } else if (state.isCropping && state.cropDrag) {
                 // Raw mouse coords converted to full image space
                 const rect = els.viewport.getBoundingClientRect();
                 const mx = (e.clientX - rect.left - state.view.x) / state.view.scale;
                 const my = (e.clientY - rect.top - state.view.y) / state.view.scale;
                 
                 const r = state.cropRect;
                 
                 if (state.cropDrag.type === 'box') {
                     const dx = mx - state.cropDrag.startX;
                     const dy = my - state.cropDrag.startY;
                     const sr = state.cropDrag.startRect;
                     r.x = Math.max(0, Math.min(state.fullDims.w - r.w, sr.x + dx));
                     r.y = Math.max(0, Math.min(state.fullDims.h - r.h, sr.y + dy));
                 } else {
                     const h = state.cropDrag.h;
                     // Simple handle logic (min size 10x10)
                     if (h === 'nw') {
                         const oldR = r.x + r.w; const oldB = r.y + r.h;
                         r.x = Math.min(mx, oldR - 10);
                         r.x = Math.max(0, r.x);
                         r.y = Math.min(my, oldB - 10);
                         r.y = Math.max(0, r.y);
                         r.w = oldR - r.x;
                         r.h = oldB - r.y;
                     } else if (h === 'se') {
                         r.w = Math.max(10, Math.min(state.fullDims.w - r.x, mx - r.x));
                         r.h = Math.max(10, Math.min(state.fullDims.h - r.y, my - r.y));
                     } else if (h === 'ne') {
                         const oldB = r.y + r.h;
                         r.y = Math.min(my, oldB - 10);
                         r.y = Math.max(0, r.y);
                         r.h = oldB - r.y;
                         r.w = Math.max(10, Math.min(state.fullDims.w - r.x, mx - r.x));
                     } else if (h === 'sw') {
                         const oldR = r.x + r.w;
                         r.x = Math.min(mx, oldR - 10);
                         r.x = Math.max(0, r.x);
                         r.w = oldR - r.x;
                         r.h = Math.max(10, Math.min(state.fullDims.h - r.y, my - r.y));
                     }
                 }
                 render();
            } else if (state.isDrawing) {
                drawStrokeDistance(coords.x, coords.y);
                render();
            }
        }

        function handlePointerUp() {
            if (state.isDrawing) saveSnapshot('draw');
            if (state.isCropping && state.cropDrag) {
                state.cropDrag = null;
                saveSnapshot('crop');
            }
            state.isPanning = false;
            state.isDrawing = false;
            updateCursorStyle();
        }

        function drawStrokeDistance(x, y, context = maskCtx, isPreview = false) {
            const startX = state.lastDrawX;
            const startY = state.lastDrawY;
            if (startX === null || startY === null) {
                drawBrushStamp(x, y, context);
                if (!isPreview) {
                    state.lastDrawX = x;
                    state.lastDrawY = y;
                }
                return;
            }
            const dx = x - startX;
            const dy = y - startY;
            const dist = Math.hypot(dx, dy);
            const size = getBrushPixelSize();
            const spacing = Math.max(1, size * 0.15);
            if (dist >= spacing) {
                const steps = dist / spacing;
                const stepX = dx / steps;
                const stepY = dy / steps;
                for (let i = 1; i <= steps; i++) {
                    const drawX = startX + stepX * i;
                    const drawY = startY + stepY * i;
                    drawBrushStamp(drawX, drawY, context);
                }
                if (!isPreview) {
                    state.lastDrawX = x;
                    state.lastDrawY = y;
                }
            }
        }

        function drawBrushStamp(x, y, context = maskCtx) {
            const size = getBrushPixelSize();
            const radius = size / 2;
            const softness = state.feather / 20; 
            if (state.isErasing) {
                context.globalCompositeOperation = 'source-over';
                if (softness === 0) {
                    context.fillStyle = 'white';
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fill();
                } else {
                    const grad = context.createRadialGradient(x, y, radius * (1 - softness), x, y, radius);
                    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    context.fillStyle = grad;
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fill();
                }
            } else {
                context.globalCompositeOperation = 'destination-out';
                if (softness === 0) {
                    context.fillStyle = 'black'; 
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fill();
                } else {
                    const grad = context.createRadialGradient(x, y, radius * (1 - softness), x, y, radius);
                    grad.addColorStop(0, 'rgba(0, 0, 0, 1)');
                    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    context.fillStyle = grad;
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fill();
                }
            }
        }

        function updateCursorStyle() {
            if (!canDraw()) return;
            if (state.isSpacePressed || state.isPanning) {
                els.viewport.classList.add('panning');
                els.cursor.style.display = 'none'; 
            } else {
                els.viewport.classList.remove('panning');
                if(!state.isCropping) els.cursor.style.display = 'block';
            }
        }
        
        // Ctrl preview loop
        function startPreviewLoop() {
            if (state.previewLoopId) return;
            const loop = () => {
                if (!state.isCtrlPressed) return;
                const now = Date.now();
                if (now - state.lastPreviewTime > 50) { 
                     updateLinePreview();
                     state.lastPreviewTime = now;
                }
                state.previewLoopId = requestAnimationFrame(loop);
            };
            state.previewLoopId = requestAnimationFrame(loop);
        }
        function stopPreviewLoop() {
            if (state.previewLoopId) {
                cancelAnimationFrame(state.previewLoopId);
                state.previewLoopId = null;
            }
        }
        function updateLinePreview() {
            if (state.lastDrawX === null || state.currentPointerX === null) return;
            const maxDim = 1920; 
            const w = maskCanvas.width; const h = maskCanvas.height;
            const scale = Math.min(1, maxDim / Math.max(w, h));
            if (!state.previewMaskCanvas) state.previewMaskCanvas = document.createElement('canvas');
            const pw = Math.floor(w * scale); const ph = Math.floor(h * scale);
            if(state.previewMaskCanvas.width !== pw || state.previewMaskCanvas.height !== ph) {
                state.previewMaskCanvas.width = pw; state.previewMaskCanvas.height = ph;
            }
            const pCtx = state.previewMaskCanvas.getContext('2d');
            pCtx.clearRect(0, 0, pw, ph);
            pCtx.drawImage(maskCanvas, 0, 0, pw, ph);
            pCtx.save(); pCtx.scale(scale, scale);
            if (state.isPolylineStart && state.lastDrawX !== null) {
                 drawBrushStamp(state.lastDrawX, state.lastDrawY, pCtx);
            }
            drawStrokeDistance(state.currentPointerX, state.currentPointerY, pCtx, true);
            pCtx.restore();
            state.isPreviewing = true;
            render();
        }

        function handleWheel(e) {
            if (!canDraw()) return;
            e.preventDefault();
            if (e.ctrlKey || e.metaKey) {
                const delta = -Math.sign(e.deltaY); 
                let newSize = state.brushPercent + delta; 
                newSize = Math.max(1, Math.min(30, newSize));
                state.brushPercent = newSize;
                els.brushSize.value = newSize;
                els.brushSizeVal.textContent = newSize;
                updateCursorSize();
                return;
            }
            const zoomSpeed = 0.1;
            const delta = -Math.sign(e.deltaY) * zoomSpeed;
            const newScale = Math.max(0.1, Math.min(10, state.view.scale * (1 + delta)));
            const rect = els.viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const canvasX = (mouseX - state.view.x) / state.view.scale;
            const canvasY = (mouseY - state.view.y) / state.view.scale;
            state.view.scale = newScale;
            state.view.x = mouseX - canvasX * newScale;
            state.view.y = mouseY - canvasY * newScale;
            updateViewTransform();
            updateCursorPos(e);
        }

        init();
        cropHandlers(); // Attach DOM listeners
    </script>
</body>
</html>
